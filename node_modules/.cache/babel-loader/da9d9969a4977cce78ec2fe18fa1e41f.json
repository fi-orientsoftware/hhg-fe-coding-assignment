{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useEffect, useState } from \"react\";\nimport { DEFAULT_PAGE, PAGE_SIZE } from \"../constants\";\n\nconst useFetchWithPagination = (fetchCallback, pageSize = PAGE_SIZE) => {\n  _s();\n\n  const [refetchEffect, setRefetchEffect] = useState(0);\n  const [data, setData] = useState();\n  const [error, setError] = useState();\n  const [isLoading, setIsLoading] = useState(false); // to check if the component is umounted before the promise fullfilled or rejected\n  // so the hook did not call setState after the component already unmounted\n  // causing memory leak.\n\n  const [isMounted, setIsMounted] = useState(true);\n  const [page, setPage] = useState(DEFAULT_PAGE);\n  const fetch = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      const params = {\n        page,\n        limit: pageSize\n      };\n      const result = await fetchCallback(params);\n\n      if (result && isMounted) {\n        setData(result.data);\n      }\n    } catch (error) {\n      if (isMounted) {\n        setError(error);\n      }\n    }\n\n    setIsLoading(false);\n  }, [page, isMounted, pageSize, fetchCallback]);\n  useEffect(() => {\n    setIsMounted(true);\n    return () => setIsMounted(false);\n  }, [setIsMounted]);\n  useEffect(() => {\n    fetch();\n  }, [page, pageSize, fetch, refetchEffect]);\n  const goToFirstPage = useCallback(() => {\n    setPage(DEFAULT_PAGE);\n  }, [setPage]);\n  const refetch = useCallback(() => setRefetchEffect(prev => prev + 1), [setRefetchEffect]);\n  return {\n    page,\n    setPage,\n    goToFirstPage,\n    isLoading,\n    data,\n    error,\n    refetch\n  };\n};\n\n_s(useFetchWithPagination, \"rNnfREOqAohC/BnYxdV5U0Y34cI=\");\n\nexport default useFetchWithPagination;","map":{"version":3,"sources":["C:/Users/aly.hanafi/Downloads/hhg-fe-coding-assignment/hhg-fe-coding-assignment/src/hook/useFetchWithPagination.ts"],"names":["useCallback","useEffect","useState","DEFAULT_PAGE","PAGE_SIZE","useFetchWithPagination","fetchCallback","pageSize","refetchEffect","setRefetchEffect","data","setData","error","setError","isLoading","setIsLoading","isMounted","setIsMounted","page","setPage","fetch","params","limit","result","goToFirstPage","refetch","prev"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,QAAjC,QAAiD,OAAjD;AACA,SAASC,YAAT,EAAuBC,SAAvB,QAAwC,cAAxC;;AAEA,MAAMC,sBAAsB,GAAG,CAC9BC,aAD8B,EAE9BC,QAAgB,GAAGH,SAFW,KAG1B;AAAA;;AACJ,QAAM,CAACI,aAAD,EAAgBC,gBAAhB,IAAoCP,QAAQ,CAAS,CAAT,CAAlD;AACA,QAAM,CAACQ,IAAD,EAAOC,OAAP,IAAkBT,QAAQ,EAAhC;AACA,QAAM,CAACU,KAAD,EAAQC,QAAR,IAAoBX,QAAQ,EAAlC;AACA,QAAM,CAACY,SAAD,EAAYC,YAAZ,IAA4Bb,QAAQ,CAAU,KAAV,CAA1C,CAJI,CAMJ;AACA;AACA;;AACA,QAAM,CAACc,SAAD,EAAYC,YAAZ,IAA4Bf,QAAQ,CAAU,IAAV,CAA1C;AAEA,QAAM,CAACgB,IAAD,EAAOC,OAAP,IAAkBjB,QAAQ,CAACC,YAAD,CAAhC;AAEA,QAAMiB,KAAK,GAAGpB,WAAW,CAAC,YAAY;AACrC,QAAI;AACHe,MAAAA,YAAY,CAAC,IAAD,CAAZ;AAEA,YAAMM,MAAM,GAAG;AAAEH,QAAAA,IAAF;AAAQI,QAAAA,KAAK,EAAEf;AAAf,OAAf;AACA,YAAMgB,MAAM,GAAG,MAAMjB,aAAa,CAACe,MAAD,CAAlC;;AAEA,UAAIE,MAAM,IAAIP,SAAd,EAAyB;AACxBL,QAAAA,OAAO,CAACY,MAAM,CAACb,IAAR,CAAP;AACA;AACD,KATD,CASE,OAAOE,KAAP,EAAc;AACf,UAAII,SAAJ,EAAe;AACdH,QAAAA,QAAQ,CAACD,KAAD,CAAR;AACA;AACD;;AACDG,IAAAA,YAAY,CAAC,KAAD,CAAZ;AACA,GAhBwB,EAgBtB,CAACG,IAAD,EAAOF,SAAP,EAAkBT,QAAlB,EAA4BD,aAA5B,CAhBsB,CAAzB;AAkBAL,EAAAA,SAAS,CAAC,MAAM;AACfgB,IAAAA,YAAY,CAAC,IAAD,CAAZ;AACA,WAAO,MAAMA,YAAY,CAAC,KAAD,CAAzB;AACA,GAHQ,EAGN,CAACA,YAAD,CAHM,CAAT;AAKAhB,EAAAA,SAAS,CAAC,MAAM;AACfmB,IAAAA,KAAK;AACL,GAFQ,EAEN,CAACF,IAAD,EAAOX,QAAP,EAAiBa,KAAjB,EAAwBZ,aAAxB,CAFM,CAAT;AAIA,QAAMgB,aAAa,GAAGxB,WAAW,CAAC,MAAM;AACvCmB,IAAAA,OAAO,CAAChB,YAAD,CAAP;AACA,GAFgC,EAE9B,CAACgB,OAAD,CAF8B,CAAjC;AAIA,QAAMM,OAAO,GAAGzB,WAAW,CAC1B,MAAMS,gBAAgB,CAAEiB,IAAD,IAAUA,IAAI,GAAG,CAAlB,CADI,EAE1B,CAACjB,gBAAD,CAF0B,CAA3B;AAKA,SAAO;AACNS,IAAAA,IADM;AAENC,IAAAA,OAFM;AAGNK,IAAAA,aAHM;AAINV,IAAAA,SAJM;AAKNJ,IAAAA,IALM;AAMNE,IAAAA,KANM;AAONa,IAAAA;AAPM,GAAP;AASA,CA7DD;;GAAMpB,sB;;AA+DN,eAAeA,sBAAf","sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\r\nimport { DEFAULT_PAGE, PAGE_SIZE } from \"../constants\";\r\n\r\nconst useFetchWithPagination = (\r\n\tfetchCallback: (params: any) => Promise<any>,\r\n\tpageSize: number = PAGE_SIZE\r\n) => {\r\n\tconst [refetchEffect, setRefetchEffect] = useState<number>(0);\r\n\tconst [data, setData] = useState<any>();\r\n\tconst [error, setError] = useState<any>();\r\n\tconst [isLoading, setIsLoading] = useState<boolean>(false);\r\n\r\n\t// to check if the component is umounted before the promise fullfilled or rejected\r\n\t// so the hook did not call setState after the component already unmounted\r\n\t// causing memory leak.\r\n\tconst [isMounted, setIsMounted] = useState<boolean>(true);\r\n\r\n\tconst [page, setPage] = useState(DEFAULT_PAGE);\r\n\r\n\tconst fetch = useCallback(async () => {\r\n\t\ttry {\r\n\t\t\tsetIsLoading(true);\r\n\r\n\t\t\tconst params = { page, limit: pageSize };\r\n\t\t\tconst result = await fetchCallback(params);\r\n\r\n\t\t\tif (result && isMounted) {\r\n\t\t\t\tsetData(result.data);\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\tif (isMounted) {\r\n\t\t\t\tsetError(error);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsetIsLoading(false);\r\n\t}, [page, isMounted, pageSize, fetchCallback]);\r\n\r\n\tuseEffect(() => {\r\n\t\tsetIsMounted(true);\r\n\t\treturn () => setIsMounted(false);\r\n\t}, [setIsMounted]);\r\n\r\n\tuseEffect(() => {\r\n\t\tfetch();\r\n\t}, [page, pageSize, fetch, refetchEffect]);\r\n\r\n\tconst goToFirstPage = useCallback(() => {\r\n\t\tsetPage(DEFAULT_PAGE);\r\n\t}, [setPage]);\r\n\r\n\tconst refetch = useCallback(\r\n\t\t() => setRefetchEffect((prev) => prev + 1),\r\n\t\t[setRefetchEffect]\r\n\t);\r\n\r\n\treturn {\r\n\t\tpage,\r\n\t\tsetPage,\r\n\t\tgoToFirstPage,\r\n\t\tisLoading,\r\n\t\tdata,\r\n\t\terror,\r\n\t\trefetch,\r\n\t};\r\n};\r\n\r\nexport default useFetchWithPagination;\r\n"]},"metadata":{},"sourceType":"module"}